// Generated by CoffeeScript 1.7.1

/*
  backbone-sql.js 0.5.7
  Copyright (c) 2013 Vidigami - https://github.com/vidigami/backbone-sql
  License: MIT (http://www.opensource.org/licenses/mit-license.php)
 */

(function() {
  var COMPARATORS, COMPARATOR_KEYS, Cursor, Knex, SqlCursor, util, _, _appendCondition, _appendConditionalWhere, _appendSort, _appendWhere, _columnName, _extractCount,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  util = require('util');

  _ = require('underscore');

  Knex = require('knex');

  Cursor = require('backbone-orm/lib/cursor');

  COMPARATORS = {
    $lt: '<',
    $lte: '<=',
    $gt: '>',
    $gte: '>=',
    $ne: '!='
  };

  COMPARATOR_KEYS = _.keys(COMPARATORS);

  _appendCondition = function(conditions, key, value) {
    var mongo_op, mongo_ops, operations, ops_length, parameter, _ref, _ref1;
    if (value != null ? value.$in : void 0) {
      if ((_ref = value.$in) != null ? _ref.length : void 0) {
        conditions.where_ins.push({
          key: key,
          value: value.$in
        });
      } else {
        conditions.abort = true;
        return conditions;
      }
    } else if (value != null ? value.$nin : void 0) {
      if ((_ref1 = value.$nin) != null ? _ref1.length : void 0) {
        conditions.where_nins.push({
          key: key,
          value: value.$nin
        });
      }
    } else if (_.isObject(value) && (ops_length = _.size(mongo_ops = _.pick(value, COMPARATOR_KEYS)))) {
      operations = [];
      for (mongo_op in mongo_ops) {
        parameter = mongo_ops[mongo_op];
        if (_.isNull(value) && (operator !== '$ne')) {
          throw new Error("Unexpected null with query key '" + key + "' operator '" + operator + "'");
        }
        operations.push({
          operator: COMPARATORS[mongo_op],
          value: parameter
        });
      }
      if (ops_length === 1) {
        conditions.where_conditionals.push(_.extend(operations[0], {
          key: key
        }));
      } else {
        conditions.where_conditionals.push({
          key: key,
          operations: operations
        });
      }
    } else {
      conditions.wheres.push({
        key: key,
        value: value
      });
    }
    return conditions;
  };

  _columnName = function(col, table) {
    if (table) {
      return "" + table + "." + col;
    } else {
      return col;
    }
  };

  _appendConditionalWhere = function(query, key, condition, table, compound) {
    var whereMethod;
    whereMethod = compound ? 'andWhere' : 'where';
    if (condition.operator === '!=') {
      return query[whereMethod](function() {
        if (_.isNull(condition.value)) {
          return this.whereNotNull(_columnName(key, table));
        } else {
          return this.where(_columnName(key, table), condition.operator, condition.value).orWhereNull(_columnName(key, table));
        }
      });
    } else {
      return query[whereMethod](_columnName(key, table), condition.operator, condition.value);
    }
  };

  _appendWhere = function(query, conditions, table) {
    var condition, _i, _j, _k, _l, _len, _len1, _len2, _len3, _ref, _ref1, _ref2, _ref3;
    _ref = conditions.wheres;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      condition = _ref[_i];
      if (_.isNull(condition.value)) {
        query.whereNull(_columnName(condition.key, table));
      } else {
        query.where(_columnName(condition.key, table), condition.value);
      }
    }
    _ref1 = conditions.where_conditionals;
    for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
      condition = _ref1[_j];
      if (condition.operations) {
        query.where(function() {
          var nested_query, operation, _k, _len2, _ref2, _results;
          operation = condition.operations.pop();
          nested_query = this;
          _appendConditionalWhere(nested_query, condition.key, operation, table, false);
          _ref2 = condition.operations;
          _results = [];
          for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
            operation = _ref2[_k];
            _results.push(_appendConditionalWhere(nested_query, condition.key, operation, table, true));
          }
          return _results;
        });
      } else if (_.isNull(condition.value)) {
        query.whereNotNull(_columnName(condition.key, table));
      } else {
        _appendConditionalWhere(query, condition.key, condition, table, false);
      }
    }
    _ref2 = conditions.where_ins;
    for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
      condition = _ref2[_k];
      query.whereIn(_columnName(condition.key, table), condition.value);
    }
    _ref3 = conditions.where_nins;
    for (_l = 0, _len3 = _ref3.length; _l < _len3; _l++) {
      condition = _ref3[_l];
      query.whereNotIn(_columnName(condition.key, table), condition.value);
    }
    return query;
  };

  _appendSort = function(query, sorts) {
    var col, dir, sort, _i, _len;
    sorts = _.isArray(sorts) ? sorts : [sorts];
    for (_i = 0, _len = sorts.length; _i < _len; _i++) {
      sort = sorts[_i];
      if (sort[0] === '-') {
        dir = 'desc';
        col = sort.substr(1);
      } else {
        dir = 'asc';
        col = sort;
      }
      query.orderBy(col, dir);
    }
    return query;
  };

  _extractCount = function(count_json) {
    var count_info;
    if (!(count_json != null ? count_json.length : void 0)) {
      return 0;
    }
    count_info = count_json[0];
    return +count_info[count_info.hasOwnProperty('count(*)') ? 'count(*)' : 'count'];
  };

  module.exports = SqlCursor = (function(_super) {
    __extends(SqlCursor, _super);

    function SqlCursor() {
      return SqlCursor.__super__.constructor.apply(this, arguments);
    }

    SqlCursor.prototype._parseConditions = function(find, cursor) {
      var conditions, key, related_conditions, related_wheres, relation, reverse_relation, value, _base, _name, _ref;
      conditions = {
        wheres: [],
        where_conditionals: [],
        where_ins: [],
        where_nins: [],
        related_wheres: {},
        joined_wheres: {}
      };
      related_wheres = {};
      for (key in find) {
        value = find[key];
        if (_.isUndefined(value)) {
          throw new Error("Unexpected undefined for query key '" + key + "'");
        }
        if (key.indexOf('.') > 0) {
          _ref = key.split('.'), relation = _ref[0], key = _ref[1];
          related_wheres[relation] || (related_wheres[relation] = {});
          related_wheres[relation][key] = value;
        } else if ((reverse_relation = this.model_type.reverseRelation(key)) && reverse_relation.join_table) {
          relation = reverse_relation.reverse_relation;
          (_base = conditions.joined_wheres)[_name = relation.key] || (_base[_name] = {
            wheres: [],
            where_conditionals: [],
            where_ins: [],
            where_nins: []
          });
          _appendCondition(conditions.joined_wheres[relation.key], key, value);
        } else {
          _appendCondition(conditions, key, value);
        }
      }
      for (relation in related_wheres) {
        related_conditions = related_wheres[relation];
        conditions.related_wheres[relation] = this._parseConditions(related_conditions);
      }
      if (cursor != null ? cursor.$ids : void 0) {
        if (!cursor.$ids.length) {
          conditions.abort = true;
          return conditions;
        }
        conditions.where_ins.push({
          key: 'id',
          value: cursor.$ids
        });
      }
      return conditions;
    };

    SqlCursor.prototype.queryToJSON = function(callback) {
      var $columns, $fields, err, from_columns, key, query, related_model_type, related_wheres, relation, to_columns, _i, _len, _ref;
      if (this.hasCursorQuery('$zero')) {
        return callback(null, this.hasCursorQuery('$one') ? null : []);
      }
      try {
        query = this.connection(this.model_type.tableName());
        this._conditions = this._parseConditions(this._find, this._cursor);
        if (this._conditions.abort) {
          return callback(null, this._cursor.$count ? 0 : (this._cursor.$one ? null : []));
        }
        _appendWhere(query, this._conditions, this.model_type.tableName());
      } catch (_error) {
        err = _error;
        return callback("Query failed for model: " + this.model_type.model_name + " with error: " + err);
      }
      if (this.hasCursorQuery('$count') || this.hasCursorQuery('$exists')) {
        this._appendRelatedWheres(query);
        this._appendJoinedWheres(query);
        if (this.hasCursorQuery('$count')) {
          return query.count('*').exec((function(_this) {
            return function(err, count_json) {
              return callback(null, _extractCount(count_json));
            };
          })(this));
        } else {
          return query.count('*').limit(1).exec((function(_this) {
            return function(err, count_json) {
              return callback(null, _extractCount(count_json) > 0);
            };
          })(this));
        }
      }
      if (this._cursor.$values) {
        $fields = this._cursor.$white_list ? _.intersection(this._cursor.$values, this._cursor.$white_list) : this._cursor.$values;
      } else if (this._cursor.$select) {
        $fields = this._cursor.$white_list ? _.intersection(this._cursor.$select, this._cursor.$white_list) : this._cursor.$select;
      } else if (this._cursor.$white_list) {
        $fields = this._cursor.$white_list;
      }
      if (this._cursor.$include) {
        this.include_keys = _.isArray(this._cursor.$include) ? this._cursor.$include : [this._cursor.$include];
        if (!this.include_keys.length) {
          throw Error("Invalid include specified: " + this.include_keys);
        }
        this.joined = true;
        to_columns = [];
        _ref = this.include_keys;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          key = _ref[_i];
          relation = this._getRelation(key);
          related_model_type = relation.reverse_relation.model_type;
          to_columns = to_columns.concat(this._prefixColumns(related_model_type));
          this._joinTo(query, relation);
          if (related_wheres = this._conditions.related_wheres[key]) {
            (this.queued_queries || (this.queued_queries = [])).push(key);
            _appendWhere(query, related_wheres, related_model_type.tableName());
          }
        }
        from_columns = this._prefixColumns(this.model_type, $fields);
        $columns = from_columns.concat(to_columns);
      } else {
        if (this._cursor.$one) {
          query.limit(1);
        }
        if (this._cursor.$limit) {
          query.limit(this._cursor.$limit);
        }
        if (this._cursor.$offset) {
          query.offset(this._cursor.$offset);
        }
      }
      this._appendRelatedWheres(query);
      this._appendJoinedWheres(query);
      $columns || ($columns = this.joined ? this._prefixColumns(this.model_type, $fields) : $fields);
      query.select($columns);
      if (this._cursor.$sort) {
        _appendSort(query, this._cursor.$sort);
      }
      if (this.verbose) {
        console.log('\n----------');
        console.log(query.toString());
        console.log('----------');
      }
      return query.exec((function(_this) {
        return function(err, json) {
          if (err) {
            return callback(new Error("Query failed for model: " + _this.model_type.model_name + " with error: " + err));
          }
          if (_this.joined) {
            json = _this._joinedResultsToJSON(json);
          }
          if (_this.queued_queries) {
            return _this._appendCompleteRelations(json, callback);
          } else {
            return _this._processResponse(json, callback);
          }
        };
      })(this));
    };

    SqlCursor.prototype._processResponse = function(json, callback) {
      var model_json, number, query, schema, _i, _len;
      schema = this.model_type.schema();
      for (_i = 0, _len = json.length; _i < _len; _i++) {
        model_json = json[_i];
        this.backbone_adapter.nativeToAttributes(model_json, schema);
      }
      json = this.selectResults(json);
      if (this._cursor.$include) {
        if (this._cursor.$offset) {
          number = json.length - this._cursor.$offset;
          if (number < 0) {
            number = 0;
          }
          json = number ? json.slice(this._cursor.$offset, this._cursor.$offset + number) : [];
        }
        if (this._cursor.$limit) {
          json = json.splice(0, Math.min(json.length, this._cursor.$limit));
        }
      }
      if (this.hasCursorQuery('$page')) {
        query = this.connection(this.model_type.tableName());
        _appendWhere(query, this._conditions);
        this._appendRelatedWheres(query);
        this._appendJoinedWheres(query);
        return query.count('*').exec((function(_this) {
          return function(err, count_json) {
            if (err) {
              return callback(err);
            }
            return callback(null, {
              offset: _this._cursor.$offset || 0,
              total_rows: _extractCount(count_json),
              rows: json
            });
          };
        })(this));
      } else {
        return callback(null, json);
      }
    };

    SqlCursor.prototype._appendCompleteRelations = function(json, callback) {
      var key, new_query, related_model_type, relation, to_columns, _i, _len, _ref;
      new_query = this.connection(this.model_type.tableName());
      new_query.whereIn(_columnName('id', this.model_type.tableName()), _.pluck(json, 'id'));
      to_columns = [];
      _ref = this.queued_queries;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        key = _ref[_i];
        relation = this._getRelation(key);
        related_model_type = relation.reverse_relation.model_type;
        to_columns = to_columns.concat(this._prefixColumns(related_model_type));
        this._joinTo(new_query, relation);
      }
      new_query.select((this._prefixColumns(this.model_type, ['id'])).concat(to_columns));
      return new_query.exec((function(_this) {
        return function(err, new_json) {
          var model, placeholder, relation_json, _j, _len1;
          relation_json = _this._joinedResultsToJSON(new_json);
          for (_j = 0, _len1 = relation_json.length; _j < _len1; _j++) {
            placeholder = relation_json[_j];
            model = _.find(json, function(test) {
              return test.id === placeholder.id;
            });
            _.extend(model, placeholder);
          }
          return _this._processResponse(json, callback);
        };
      })(this));
    };

    SqlCursor.prototype._appendRelatedWheres = function(query) {
      var key, related_wheres, relation, _ref, _results;
      if (_.isEmpty(this._conditions.related_wheres)) {
        return;
      }
      this.joined = true;
      if (this.include_keys) {
        this._conditions.related_wheres = _.omit(this._conditions.related_wheres, this.include_keys);
      }
      _ref = this._conditions.related_wheres;
      _results = [];
      for (key in _ref) {
        related_wheres = _ref[key];
        relation = this._getRelation(key);
        this._joinTo(query, relation);
        _results.push(_appendWhere(query, related_wheres, relation.reverse_relation.model_type.tableName()));
      }
      return _results;
    };

    SqlCursor.prototype._appendJoinedWheres = function(query) {
      var from_key, joined_wheres, key, relation, to_key, _ref, _results;
      if (_.isEmpty(this._conditions.joined_wheres)) {
        return;
      }
      this.joined = true;
      _ref = this._conditions.joined_wheres;
      _results = [];
      for (key in _ref) {
        joined_wheres = _ref[key];
        relation = this._getRelation(key);
        if (!(__indexOf.call(_.keys(this._conditions.related_wheres), key) >= 0 || (this.include_keys && __indexOf.call(this.include_keys, key) >= 0))) {
          from_key = "" + (this.model_type.tableName()) + ".id";
          to_key = "" + (relation.join_table.tableName()) + "." + relation.foreign_key;
          query.join(relation.join_table.tableName(), from_key, to_key, 'left outer');
        }
        _results.push(_appendWhere(query, joined_wheres, relation.join_table.tableName()));
      }
      return _results;
    };

    SqlCursor.prototype._joinTo = function(query, relation) {
      var from_key, pivot_from_key, pivot_table, pivot_to_key, related_model_type, to_key;
      related_model_type = relation.reverse_relation.model_type;
      if (relation.type === 'hasMany' && relation.reverse_relation.type === 'hasMany') {
        pivot_table = relation.join_table.tableName();
        from_key = "" + (this.model_type.tableName()) + ".id";
        pivot_to_key = "" + pivot_table + "." + relation.foreign_key;
        query.join(pivot_table, from_key, pivot_to_key, 'left outer');
        pivot_from_key = "" + pivot_table + "." + relation.reverse_relation.foreign_key;
        to_key = "" + (related_model_type.tableName()) + ".id";
        return query.join(related_model_type.tableName(), pivot_from_key, to_key, 'left outer');
      } else {
        if (relation.type === 'belongsTo') {
          from_key = "" + (this.model_type.tableName()) + "." + relation.foreign_key;
          to_key = "" + (related_model_type.tableName()) + ".id";
        } else {
          from_key = "" + (this.model_type.tableName()) + ".id";
          to_key = "" + (related_model_type.tableName()) + "." + relation.foreign_key;
        }
        return query.join(related_model_type.tableName(), from_key, to_key, 'left outer');
      }
    };

    SqlCursor.prototype._joinedResultsToJSON = function(raw_json) {
      var found, include_key, json, key, match, model_json, related_json, related_model_type, reverse_relation_schema, row, row_relation_json, value, _i, _j, _len, _len1, _ref;
      if (!(raw_json && raw_json.length)) {
        return raw_json;
      }
      json = [];
      for (_i = 0, _len = raw_json.length; _i < _len; _i++) {
        row = raw_json[_i];
        model_json = {};
        row_relation_json = {};
        for (key in row) {
          value = row[key];
          if (match = this._prefixRegex(this.model_type).exec(key)) {
            model_json[match[1]] = value;
          } else if (this.include_keys) {
            _ref = this.include_keys;
            for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
              include_key = _ref[_j];
              related_json = (row_relation_json[include_key] || (row_relation_json[include_key] = {}));
              related_model_type = this.model_type.relation(include_key).reverse_relation.model_type;
              if (match = this._prefixRegex(related_model_type).exec(key)) {
                related_json[match[1]] = value;
              }
            }
          }
        }
        if (found = _.find(json, function(test) {
          return test.id === model_json.id;
        })) {
          model_json = found;
        } else {
          json.push(model_json);
        }
        for (include_key in row_relation_json) {
          related_json = row_relation_json[include_key];
          if (_.isNull(related_json.id)) {
            if (this.model_type.relation(include_key).type === 'hasMany') {
              model_json[include_key] = [];
            } else {
              model_json[include_key] = null;
            }
          } else if (!_.isEmpty(related_json)) {
            reverse_relation_schema = this.model_type.relation(include_key).reverse_relation.model_type.schema();
            related_json = this.backbone_adapter.nativeToAttributes(related_json, reverse_relation_schema);
            if (this.model_type.relation(include_key).type === 'hasMany') {
              model_json[include_key] || (model_json[include_key] = []);
              if (!_.find(model_json[include_key], function(test) {
                return test.id === related_json.id;
              })) {
                model_json[include_key].push(related_json);
              }
            } else {
              model_json[include_key] = related_json;
            }
          }
        }
      }
      return json;
    };

    SqlCursor.prototype._prefixColumns = function(model_type, fields) {
      var col, columns;
      columns = fields ? _.clone(fields) : model_type.schema().allColumns();
      if (__indexOf.call(columns, 'id') < 0) {
        columns.push('id');
      }
      return (function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = columns.length; _i < _len; _i++) {
          col = columns[_i];
          _results.push("" + (model_type.tableName()) + "." + col + " as " + (this._tablePrefix(model_type)) + col);
        }
        return _results;
      }).call(this);
    };

    SqlCursor.prototype._tablePrefix = function(model_type) {
      return "" + (model_type.tableName()) + "_";
    };

    SqlCursor.prototype._prefixRegex = function(model_type) {
      return new RegExp("^" + (this._tablePrefix(model_type)) + "(.*)$");
    };

    SqlCursor.prototype._getRelation = function(key) {
      var relation;
      if (!(relation = this.model_type.relation(key))) {
        throw new Error("" + key + " is not a relation of " + this.model_type.model_name);
      }
      return relation;
    };

    return SqlCursor;

  })(Cursor);

}).call(this);
