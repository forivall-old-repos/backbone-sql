// Generated by CoffeeScript 1.7.1

/*
  backbone-sql.js 0.5.10
  Copyright (c) 2013 Vidigami - https://github.com/vidigami/backbone-sql
  License: MIT (http://www.opensource.org/licenses/mit-license.php)
 */

(function() {
  var Backbone, Connection, DESTROY_BATCH_LIMIT, DatabaseTools, DatabaseURL, ModelCache, ModelTypeID, QueryCache, Queue, Schema, SqlCursor, SqlSync, Utils, inflection, modelExtensions, util, _,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  util = require('util');

  _ = require('underscore');

  Backbone = require('backbone');

  inflection = require('inflection');

  Queue = require('backbone-orm/lib/queue');

  DatabaseURL = require('backbone-orm/lib/database_url');

  Schema = require('backbone-orm/lib/schema');

  Utils = require('backbone-orm/lib/utils');

  ModelCache = require('backbone-orm/lib/cache/singletons').ModelCache;

  QueryCache = require('backbone-orm/lib/cache/singletons').QueryCache;

  ModelTypeID = require('backbone-orm/lib/cache/singletons').ModelTypeID;

  modelExtensions = require('backbone-orm/lib/extensions/model');

  Connection = require('./connection');

  SqlCursor = require('./cursor');

  DatabaseTools = require('./database_tools');

  DESTROY_BATCH_LIMIT = 1000;

  SqlSync = (function() {
    function SqlSync(model_type, options) {
      var key, value;
      this.model_type = model_type;
      if (options == null) {
        options = {};
      }
      this.db = __bind(this.db, this);
      this.getConnection = __bind(this.getConnection, this);
      this.getTable = __bind(this.getTable, this);
      this["delete"] = __bind(this["delete"], this);
      this.update = __bind(this.update, this);
      this.create = __bind(this.create, this);
      for (key in options) {
        value = options[key];
        this[key] = value;
      }
      this.model_type.model_name = Utils.findOrGenerateModelName(this.model_type);
      this.model_type.model_id = ModelTypeID.generate(this.model_type);
      this.schema = new Schema(this.model_type);
      this.backbone_adapter = require('./backbone_adapter');
    }

    SqlSync.prototype.read = function(model, options) {
      if (model.models) {
        return this.cursor().toJSON((function(_this) {
          return function(err, json) {
            if (err) {
              return options.error(err);
            }
            if (!json) {
              return options.error(new Error('Collection not fetched'));
            }
            return typeof options.success === "function" ? options.success(json) : void 0;
          };
        })(this));
      } else {
        return this.cursor(model.id).toJSON((function(_this) {
          return function(err, json) {
            if (err) {
              return options.error(err);
            }
            if (!json) {
              return options.error(new Error("Model not found. Id " + model.id));
            }
            return options.success(json);
          };
        })(this));
      }
    };

    SqlSync.prototype.create = function(model, options) {
      var json;
      json = model.toJSON();
      return this.getTable('master').insert(json, 'id').exec((function(_this) {
        return function(err, res) {
          if (err) {
            return options.error(err);
          }
          if (!(res != null ? res.length : void 0)) {
            return options.error(new Error("Failed to create model with attributes: " + (util.inspect(model.attributes))));
          }
          return QueryCache.reset(_this.model_type, function(err) {
            if (err) {
              return typeof options.error === "function" ? options.error(err) : void 0;
            }
            json.id = res[0];
            return options.success(json);
          });
        };
      })(this));
    };

    SqlSync.prototype.update = function(model, options) {
      var json;
      json = model.toJSON();
      return this.getTable('master').where('id', model.id).update(json).exec((function(_this) {
        return function(err, res) {
          if (err) {
            return options.error(err);
          }
          return QueryCache.reset(_this.model_type, function(err) {
            if (err) {
              return typeof options.error === "function" ? options.error(err) : void 0;
            }
            return options.success(json);
          });
        };
      })(this));
    };

    SqlSync.prototype["delete"] = function(model, options) {
      return this.getTable('master').where('id', model.id).del().exec((function(_this) {
        return function(err, res) {
          if (err) {
            return options.error(err);
          }
          return QueryCache.reset(_this.model_type, function(err) {
            if (err) {
              return typeof options.error === "function" ? options.error(err) : void 0;
            }
            return options.success();
          });
        };
      })(this));
    };

    SqlSync.prototype.resetSchema = function(options, callback) {
      return this.db().resetSchema(options, callback);
    };

    SqlSync.prototype.cursor = function(query) {
      var options;
      if (query == null) {
        query = {};
      }
      options = _.pick(this, ['model_type', 'backbone_adapter']);
      options.connection = this.getConnection();
      return new SqlCursor(query, options);
    };

    SqlSync.prototype.destroy = function(query, callback) {
      return this.model_type.each(_.extend({
        $each: {
          limit: DESTROY_BATCH_LIMIT,
          json: true
        }
      }, query), ((function(_this) {
        return function(model_json, callback) {
          return Utils.patchRemoveByJSON(_this.model_type, model_json, function(err) {
            if (err) {
              return callback(err);
            }
            return _this.getTable('master').where('id', model_json.id).del().exec(function(err) {
              if (err) {
                return callback(err);
              }
              return QueryCache.reset(_this.model_type, callback);
            });
          });
        };
      })(this)), callback);
    };

    SqlSync.prototype.initialize = function() {
      var url;
      if (this.is_initialized) {
        return;
      }
      this.is_initialized = true;
      this.schema.initialize();
      if (!(url = _.result(new this.model_type, 'url'))) {
        throw new Error("Missing url for model");
      }
      return this.connect(url);
    };

    SqlSync.prototype.connect = function(url) {
      var connection, slave_url, _i, _len, _ref, _ref1;
      this.table = (new DatabaseURL(url)).table;
      this.connections || (this.connections = {
        all: [],
        master: new Connection(url),
        slaves: []
      });
      if ((_ref = this.slaves) != null ? _ref.length : void 0) {
        _ref1 = this.slaves;
        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
          slave_url = _ref1[_i];
          this.connections.slaves.push(connection = new Connection("" + slave_url + "/" + this.table));
        }
      }
      this.connections.all = [this.connections.master].concat(this.connections.slaves);
      return this.schema.initialize();
    };

    SqlSync.prototype.getTable = function(db_type) {
      return this.getConnection(db_type)(this.table);
    };

    SqlSync.prototype.getConnection = function(db_type) {
      if (db_type === 'master' || this.connections.all.length === 1) {
        return this.connections.master.knex();
      }
      return this.connections.all[~~(Math.random() * this.connections.all.length)].knex();
    };

    SqlSync.prototype.db = function() {
      return this.db_tools || (this.db_tools = new DatabaseTools(this.connections.master, this.table, this.schema));
    };

    return SqlSync;

  })();

  module.exports = function(type, options) {
    var model_type, sync, sync_fn;
    if (Utils.isCollection(new type())) {
      model_type = Utils.configureCollectionModelType(type, module.exports);
      return type.prototype.sync = model_type.prototype.sync;
    }
    sync = new SqlSync(type, options);
    type.prototype.sync = sync_fn = function(method, model, options) {
      if (options == null) {
        options = {};
      }
      sync.initialize();
      if (method === 'createSync') {
        return module.exports.apply(null, Array.prototype.slice.call(arguments, 1));
      }
      if (method === 'sync') {
        return sync;
      }
      if (method === 'db') {
        return sync.db();
      }
      if (method === 'schema') {
        return sync.schema;
      }
      if (method === 'isRemote') {
        return false;
      }
      if (method === 'tableName') {
        return sync.table;
      }
      if (sync[method]) {
        return sync[method].apply(sync, Array.prototype.slice.call(arguments, 1));
      } else {
        return void 0;
      }
    };
    modelExtensions(type);
    return ModelCache.configureSync(type, sync_fn);
  };

}).call(this);
