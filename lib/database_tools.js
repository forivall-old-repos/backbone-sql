// Generated by CoffeeScript 1.7.1

/*
  backbone-sql.js 0.5.7
  Copyright (c) 2013 Vidigami - https://github.com/vidigami/backbone-sql
  License: MIT (http://www.opensource.org/licenses/mit-license.php)
 */

(function() {
  var DatabaseTools, KNEX_COLUMN_OPERATORS, KNEX_COLUMN_OPTIONS, Knex, Queue, debounceCallback, inflection, _,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  _ = require('underscore');

  inflection = require('inflection');

  Knex = require('knex');

  Queue = require('backbone-orm/lib/queue');

  KNEX_COLUMN_OPERATORS = ['indexed', 'nullable', 'unique'];

  KNEX_COLUMN_OPTIONS = ['textType', 'length', 'precision', 'scale', 'value', 'values'];

  debounceCallback = function(callback) {
    var debounced_callback;
    return debounced_callback = function() {
      if (debounced_callback.was_called) {
        return;
      }
      debounced_callback.was_called = true;
      return callback.apply(null, Array.prototype.slice.call(arguments, 0));
    };
  };

  module.exports = DatabaseTools = (function() {
    function DatabaseTools(connection, table_name, schema, options) {
      var _ref;
      this.connection = connection;
      this.table_name = table_name;
      this.schema = schema;
      if (options == null) {
        options = {};
      }
      this.renameTable = __bind(this.renameTable, this);
      this.dropTableIfExists = __bind(this.dropTableIfExists, this);
      this.dropTable = __bind(this.dropTable, this);
      this.hasTable = __bind(this.hasTable, this);
      this.hasColumn = __bind(this.hasColumn, this);
      this.ensureColumn = __bind(this.ensureColumn, this);
      this.ensureField = __bind(this.ensureField, this);
      this.ensureRelation = __bind(this.ensureRelation, this);
      this.ensureSchemaForExistingTable = __bind(this.ensureSchemaForExistingTable, this);
      this.ensureSchema = __bind(this.ensureSchema, this);
      this.resetSchema = __bind(this.resetSchema, this);
      this.resetRelation = __bind(this.resetRelation, this);
      this.addRelation = __bind(this.addRelation, this);
      this.addColumn = __bind(this.addColumn, this);
      this.addIDColumn = __bind(this.addIDColumn, this);
      this.addField = __bind(this.addField, this);
      this.editTable = __bind(this.editTable, this);
      this.createTable = __bind(this.createTable, this);
      this.end = __bind(this.end, this);
      this.strict = (_ref = options.strict) != null ? _ref : true;
      this.join_table_operations = [];
    }

    DatabaseTools.prototype.end = function(callback) {
      var join_table_fn, queue, _fn, _i, _len, _ref;
      if (!this.join_table_operations.length) {
        return callback();
      }
      queue = new Queue(1);
      _ref = this.join_table_operations;
      _fn = (function(_this) {
        return function(join_table_fn) {
          return queue.defer(function(callback) {
            return join_table_fn(callback);
          });
        };
      })(this);
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        join_table_fn = _ref[_i];
        _fn(join_table_fn);
      }
      return queue.await((function(_this) {
        return function(err) {
          _this.join_table_operations = [];
          return callback(err);
        };
      })(this));
    };

    DatabaseTools.prototype.createTable = function(callback) {
      if (!_.isFunction(callback)) {
        throw new Error("createTable requires a callback");
      }
      callback = debounceCallback(callback);
      this.connection.knex().schema.createTable(this.table_name, (function(_this) {
        return function(t) {
          return callback(null, t);
        };
      })(this)).exec(callback);
      return this;
    };

    DatabaseTools.prototype.editTable = function(callback) {
      if (!_.isFunction(callback)) {
        throw new Error("editTable requires a callback");
      }
      callback = debounceCallback(callback);
      this.connection.knex().schema.table(this.table_name, (function(_this) {
        return function(t) {
          return callback(null, t);
        };
      })(this)).exec(callback);
      return this;
    };

    DatabaseTools.prototype.addField = function(table, key, field) {
      var type;
      type = "" + (field.type[0].toLowerCase()) + (field.type.slice(1));
      this.addColumn(table, key, type, field);
      return this;
    };

    DatabaseTools.prototype.addIDColumn = function(table) {
      return this.addColumn(table, 'id', 'increments', ['primary']);
    };

    DatabaseTools.prototype.addColumn = function(table, key, type, options) {
      var column, column_args, constructor_options, knex_methods, method, _i, _len;
      if (options == null) {
        options = {};
      }
      column_args = [key];
      constructor_options = _.pick(options, KNEX_COLUMN_OPTIONS);
      if (!_.isEmpty(constructor_options)) {
        if (type === 'float' || type === 'decimal') {
          column_args[1] = constructor_options['precision'];
          column_args[2] = constructor_options['scale'];
        } else {
          column_args[1] = _.values(constructor_options)[0];
        }
      }
      column = table[type].apply(table, column_args);
      knex_methods = [];
      if (options.nullable === false) {
        knex_methods.push['notNullable'];
      }
      if (options.indexed) {
        knex_methods.push('index');
      }
      if (options.unique) {
        knex_methods.push('unique');
      }
      for (_i = 0, _len = knex_methods.length; _i < _len; _i++) {
        method = knex_methods[_i];
        column[method]();
      }
      return this;
    };

    DatabaseTools.prototype.addRelation = function(table, key, relation) {
      if (relation.isVirtual()) {
        return;
      }
      if (relation.type === 'belongsTo') {
        this.addColumn(table, relation.foreign_key, 'integer', ['nullable', 'index']);
      } else if (relation.type === 'hasMany' && relation.reverse_relation.type === 'hasMany') {
        this.join_table_operations.push(function(callback) {
          return relation.findOrGenerateJoinTable().db().ensureSchema(callback);
        });
      }
      return this;
    };

    DatabaseTools.prototype.resetRelation = function(table, key, relation) {
      if (relation.isVirtual()) {
        return;
      }
      if (relation.type === 'belongsTo') {
        this.addColumn(table, relation.foreign_key, 'integer', ['nullable', 'index']);
      } else if (relation.type === 'hasMany' && relation.reverse_relation.type === 'hasMany') {
        this.join_table_operations.push(function(callback) {
          return relation.findOrGenerateJoinTable().resetSchema(callback);
        });
      }
      return this;
    };

    DatabaseTools.prototype.resetSchema = function(options, callback) {
      if (arguments.length === 1) {
        callback = options;
        options = {};
      }
      return this.connection.knex().schema.dropTableIfExists(this.table_name).exec((function(_this) {
        return function(err) {
          if (err) {
            return callback(err);
          }
          return _this.createTable(function(err, table) {
            var field, key, relation, _ref, _ref1;
            if (err) {
              return callback(err);
            }
            if (options.verbose) {
              console.log("Creating table: " + _this.table_name + " with fields: '" + (_.keys(_this.schema.fields).join(', ')) + "' and relations: '" + (_.keys(_this.schema.relations).join(', ')) + "'");
            }
            _this.addIDColumn(table);
            _ref = _this.schema.fields;
            for (key in _ref) {
              field = _ref[key];
              _this.addField(table, key, field);
            }
            _ref1 = _this.schema.relations;
            for (key in _ref1) {
              relation = _ref1[key];
              _this.resetRelation(table, key, relation);
            }
            return _this.end(callback);
          });
        };
      })(this));
    };

    DatabaseTools.prototype.ensureSchema = function(options, callback) {
      if (arguments.length === 1) {
        callback = options;
        options = {};
      }
      if (this.ensuring) {
        return callback();
      }
      this.ensuring = true;
      return this.hasTable((function(_this) {
        return function(err, table_exists) {
          if (err) {
            _this.ensuring = false;
            return callback(err);
          }
          if (options.verbose) {
            console.log("Ensuring table: " + _this.table_name + " with fields: '" + (_.keys(_this.schema.fields).join(', ')) + "' and relations: '" + (_.keys(_this.schema.relations).join(', ')) + "'");
          }
          if (!table_exists) {
            return _this.createTable(function(err, table) {
              if (err) {
                return callback(err);
              }
              _this.addIDColumn(table);
              return _this.end(function(err) {
                if (err) {
                  _this.ensuring = false;
                  return callback(err);
                }
                return _this.ensureSchemaForExistingTable(options, function(err) {
                  _this.ensuring = false;
                  return callback(err);
                });
              });
            });
          } else {
            return _this.ensureSchemaForExistingTable(options, function(err) {
              _this.ensuring = false;
              return callback(err);
            });
          }
        };
      })(this));
    };

    DatabaseTools.prototype.ensureSchemaForExistingTable = function(options, callback) {
      return this.editTable((function(_this) {
        return function(err, table) {
          var field, key, queue, relation, _fn, _fn1, _ref, _ref1;
          if (err) {
            return callback(err);
          }
          queue = new Queue(1);
          queue.defer(function(callback) {
            return _this.ensureColumn(table, 'id', 'increments', ['primary'], callback);
          });
          if (_this.schema.fields) {
            _ref = _this.schema.fields;
            _fn = function(key, field) {
              return queue.defer(function(callback) {
                return _this.ensureField(table, key, field, callback);
              });
            };
            for (key in _ref) {
              field = _ref[key];
              _fn(key, field);
            }
          }
          if (_this.schema.relations) {
            _ref1 = _this.schema.relations;
            _fn1 = function(key, relation) {
              return queue.defer(function(callback) {
                return _this.ensureRelation(table, key, relation, callback);
              });
            };
            for (key in _ref1) {
              relation = _ref1[key];
              _fn1(key, relation);
            }
          }
          return queue.await(function(err) {
            if (err) {
              return callback(err);
            }
            return _this.end(callback);
          });
        };
      })(this));
    };

    DatabaseTools.prototype.ensureRelation = function(table, key, relation, callback) {
      if (relation.type === 'belongsTo') {
        return this.hasColumn(relation.foreign_key, (function(_this) {
          return function(err, column_exists) {
            if (err) {
              return callback(err);
            }
            if (!column_exists) {
              _this.addRelation(table, key, relation);
            }
            return callback();
          };
        })(this));
      } else if (relation.type === 'hasMany' && relation.reverse_relation.type === 'hasMany') {
        return relation.findOrGenerateJoinTable().db().ensureSchema(callback);
      } else {
        return callback();
      }
    };

    DatabaseTools.prototype.ensureField = function(table, key, field, callback) {
      return this.hasColumn(key, (function(_this) {
        return function(err, column_exists) {
          if (err) {
            return callback(err);
          }
          if (!column_exists) {
            _this.addField(table, key, field);
          }
          return callback();
        };
      })(this));
    };

    DatabaseTools.prototype.ensureColumn = function(table, key, type, options, callback) {
      return this.hasColumn(key, (function(_this) {
        return function(err, column_exists) {
          if (err) {
            return callback(err);
          }
          if (!column_exists) {
            _this.addColumn(table, key, type, options);
          }
          return callback();
        };
      })(this));
    };

    DatabaseTools.prototype.hasColumn = function(column, callback) {
      return this.connection.knex().schema.hasColumn(this.table_name, column).exec(callback);
    };

    DatabaseTools.prototype.hasTable = function(callback) {
      return this.connection.knex().schema.hasTable(this.table_name).exec(callback);
    };

    DatabaseTools.prototype.dropTable = function(callback) {
      return this.connection.knex().schema.dropTable(this.table_name).exec(callback);
    };

    DatabaseTools.prototype.dropTableIfExists = function(callback) {
      return this.connection.knex().schema.dropTableIfExists(this.table_name).exec(callback);
    };

    DatabaseTools.prototype.renameTable = function(to, callback) {
      return this.connection.knex().schema.renameTable(this.table_name, to).exec(callback);
    };

    return DatabaseTools;

  })();

}).call(this);
