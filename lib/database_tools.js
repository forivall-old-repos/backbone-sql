// Generated by CoffeeScript 1.6.3
/*
  backbone-sql.js 0.5.2
  Copyright (c) 2013 Vidigami - https://github.com/vidigami/backbone-sql
  License: MIT (http://www.opensource.org/licenses/mit-license.php)
*/


(function() {
  var DatabaseTools, KNEX_COLUMN_OPERATORS, KNEX_COLUMN_OPTIONS, Knex, Queue, inflection, _,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  _ = require('underscore');

  inflection = require('inflection');

  Knex = require('knex');

  Queue = require('backbone-orm/lib/queue');

  KNEX_COLUMN_OPERATORS = ['indexed', 'nullable', 'unique'];

  KNEX_COLUMN_OPTIONS = ['textType', 'length', 'precision', 'scale', 'value', 'values'];

  module.exports = DatabaseTools = (function() {
    function DatabaseTools(connection, table_name, schema, options) {
      var _ref;
      this.connection = connection;
      this.table_name = table_name;
      this.schema = schema;
      if (options == null) {
        options = {};
      }
      this.renameTable = __bind(this.renameTable, this);
      this.dropTableIfExists = __bind(this.dropTableIfExists, this);
      this.dropTable = __bind(this.dropTable, this);
      this.hasTable = __bind(this.hasTable, this);
      this.hasColumn = __bind(this.hasColumn, this);
      this.ensureColumn = __bind(this.ensureColumn, this);
      this.ensureField = __bind(this.ensureField, this);
      this.ensureRelation = __bind(this.ensureRelation, this);
      this.ensureSchemaForExistingTable = __bind(this.ensureSchemaForExistingTable, this);
      this.ensureSchema = __bind(this.ensureSchema, this);
      this.resetSchema = __bind(this.resetSchema, this);
      this.resetRelation = __bind(this.resetRelation, this);
      this.addRelation = __bind(this.addRelation, this);
      this.addColumn = __bind(this.addColumn, this);
      this.addIDColumn = __bind(this.addIDColumn, this);
      this.addField = __bind(this.addField, this);
      this.editTable = __bind(this.editTable, this);
      this.createTable = __bind(this.createTable, this);
      this.end = __bind(this.end, this);
      this.reset = __bind(this.reset, this);
      this.strict = (_ref = options.strict) != null ? _ref : true;
      this.join_table_operations = [];
      this.reset();
    }

    DatabaseTools.prototype.reset = function() {
      this.promise = this.table = null;
      return this;
    };

    DatabaseTools.prototype.end = function(callback) {
      var _this = this;
      if (!this.promise) {
        if (this.strict) {
          return callback(new Error('end() called with no operations in progress, call createTable or editTable first'));
        }
        return callback();
      }
      return this.promise.exec(function(err) {
        var join_table_fn, queue, _fn, _i, _len, _ref;
        _this.reset();
        if (err) {
          return callback(err);
        }
        if (_this.join_table_operations.length) {
          queue = new Queue(1);
          _ref = _this.join_table_operations;
          _fn = function(join_table_fn) {
            return queue.defer(function(callback) {
              return join_table_fn(callback);
            });
          };
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            join_table_fn = _ref[_i];
            _fn(join_table_fn);
          }
          return queue.await(function(err) {
            _this.join_table_operations = [];
            return callback(err);
          });
        } else {
          return callback();
        }
      });
    };

    DatabaseTools.prototype.createTable = function() {
      var _this = this;
      if (this.promise && this.table) {
        if (this.strict) {
          throw Error("Table operation on " + this.table_name + " already in progress, call end() first");
        }
        return this;
      }
      this.promise = this.connection.knex().schema.createTable(this.table_name, function(t) {
        return _this.table = t;
      });
      return this;
    };

    DatabaseTools.prototype.editTable = function() {
      var _this = this;
      if (this.promise && this.table) {
        if (this.strict) {
          throw Error("Table operation on " + this.table_name + " already in progress, call end() first");
        }
        return this;
      }
      this.promise = this.connection.knex().schema.table(this.table_name, function(t) {
        return _this.table = t;
      });
      return this;
    };

    DatabaseTools.prototype.addField = function(key, field) {
      var type;
      if (!this.table) {
        this.editTable();
      }
      type = "" + (field.type[0].toLowerCase()) + (field.type.slice(1));
      this.addColumn(key, type, field);
      return this;
    };

    DatabaseTools.prototype.addIDColumn = function() {
      return this.addColumn('id', 'increments', ['primary']);
    };

    DatabaseTools.prototype.addColumn = function(key, type, options) {
      var column, column_args, constructor_options, knex_methods, method, _i, _len;
      if (options == null) {
        options = {};
      }
      if (!this.table) {
        this.editTable();
      }
      column_args = [key];
      constructor_options = _.pick(options, KNEX_COLUMN_OPTIONS);
      if (!_.isEmpty(constructor_options)) {
        if (type === 'float' || type === 'decimal') {
          column_args[1] = constructor_options['precision'];
          column_args[2] = constructor_options['scale'];
        } else {
          column_args[1] = _.values(constructor_options)[0];
        }
      }
      column = this.table[type].apply(this.table, column_args);
      knex_methods = [];
      if (options.nullable === false) {
        knex_methods.push['notNullable'];
      }
      if (options.indexed) {
        knex_methods.push('index');
      }
      if (options.unique) {
        knex_methods.push('unique');
      }
      for (_i = 0, _len = knex_methods.length; _i < _len; _i++) {
        method = knex_methods[_i];
        column[method]();
      }
      return this;
    };

    DatabaseTools.prototype.addRelation = function(key, relation) {
      if (!this.table) {
        this.editTable();
      }
      if (relation.isVirtual()) {
        return;
      }
      if (relation.type === 'belongsTo') {
        this.addColumn(relation.foreign_key, 'integer', ['nullable', 'index']);
      } else if (relation.type === 'hasMany' && relation.reverse_relation.type === 'hasMany') {
        this.join_table_operations.push(function(callback) {
          return relation.findOrGenerateJoinTable().db().ensureSchema(callback);
        });
      }
      return this;
    };

    DatabaseTools.prototype.resetRelation = function(key, relation) {
      if (!this.table) {
        this.editTable();
      }
      if (relation.isVirtual()) {
        return;
      }
      if (relation.type === 'belongsTo') {
        this.addColumn(relation.foreign_key, 'integer', ['nullable', 'index']);
      } else if (relation.type === 'hasMany' && relation.reverse_relation.type === 'hasMany') {
        this.join_table_operations.push(function(callback) {
          return relation.findOrGenerateJoinTable().resetSchema(callback);
        });
      }
      return this;
    };

    DatabaseTools.prototype.resetSchema = function(options, callback) {
      var _this = this;
      if (arguments.length === 1) {
        callback = options;
        options = {};
      }
      return this.connection.knex().schema.dropTableIfExists(this.table_name).exec(function(err) {
        var field, key, relation, _ref, _ref1;
        if (err) {
          return callback(err);
        }
        _this.createTable();
        if (options.verbose) {
          console.log("Creating table: " + _this.table_name + " with fields: '" + (_.keys(_this.schema.fields).join(', ')) + "' and relations: '" + (_.keys(_this.schema.relations).join(', ')) + "'");
        }
        _this.addIDColumn();
        _ref = _this.schema.fields;
        for (key in _ref) {
          field = _ref[key];
          _this.addField(key, field);
        }
        _ref1 = _this.schema.relations;
        for (key in _ref1) {
          relation = _ref1[key];
          _this.resetRelation(key, relation);
        }
        return _this.end(callback);
      });
    };

    DatabaseTools.prototype.ensureSchema = function(options, callback) {
      var _this = this;
      if (arguments.length === 1) {
        callback = options;
        options = {};
      }
      if (this.ensuring) {
        return callback();
      }
      this.ensuring = true;
      return this.hasTable(function(err, table_exists) {
        if (err) {
          return callback(err);
        }
        if (options.verbose) {
          console.log("Ensuring table: " + _this.table_name + " with fields: '" + (_.keys(_this.schema.fields).join(', ')) + "' and relations: '" + (_.keys(_this.schema.relations).join(', ')) + "'");
        }
        if (!table_exists) {
          _this.createTable();
          _this.addIDColumn();
          return _this.end(function(err) {
            if (err) {
              return callback(err);
            }
            return _this.ensureSchemaForExistingTable(options, function(err) {
              _this.ensuring = false;
              return callback(err);
            });
          });
        } else {
          return _this.ensureSchemaForExistingTable(options, function(err) {
            _this.ensuring = false;
            return callback(err);
          });
        }
      });
    };

    DatabaseTools.prototype.ensureSchemaForExistingTable = function(options, callback) {
      var field, key, queue, relation, _fn, _fn1, _ref, _ref1,
        _this = this;
      this.editTable();
      queue = new Queue(1);
      queue.defer(function(callback) {
        return _this.ensureColumn('id', 'increments', ['primary'], callback);
      });
      _ref = this.schema.fields;
      _fn = function(key, field) {
        return queue.defer(function(callback) {
          return _this.ensureField(key, field, callback);
        });
      };
      for (key in _ref) {
        field = _ref[key];
        _fn(key, field);
      }
      _ref1 = this.schema.relations;
      _fn1 = function(key, relation) {
        return queue.defer(function(callback) {
          return _this.ensureRelation(key, relation, callback);
        });
      };
      for (key in _ref1) {
        relation = _ref1[key];
        _fn1(key, relation);
      }
      return queue.await(function(err) {
        if (err) {
          return callback(err);
        }
        _this.ensuring = false;
        return _this.end(callback);
      });
    };

    DatabaseTools.prototype.ensureRelation = function(key, relation, callback) {
      var _this = this;
      if (relation.type === 'belongsTo') {
        return this.hasColumn(relation.foreign_key, function(err, column_exists) {
          if (err) {
            return callback(err);
          }
          if (!column_exists) {
            _this.addRelation(key, relation);
          }
          return callback();
        });
      } else if (relation.type === 'hasMany' && relation.reverse_relation.type === 'hasMany') {
        return relation.findOrGenerateJoinTable().db().ensureSchema(callback);
      } else {
        return callback();
      }
    };

    DatabaseTools.prototype.ensureField = function(key, field, callback) {
      var _this = this;
      return this.hasColumn(key, function(err, column_exists) {
        if (err) {
          return callback(err);
        }
        if (!column_exists) {
          _this.addField(key, field);
        }
        return callback();
      });
    };

    DatabaseTools.prototype.ensureColumn = function(key, type, options, callback) {
      var _this = this;
      if (!this.table) {
        this.editTable();
      }
      return this.hasColumn(key, function(err, column_exists) {
        if (err) {
          return callback(err);
        }
        if (!column_exists) {
          _this.addColumn(key, type, options);
        }
        return callback();
      });
    };

    DatabaseTools.prototype.hasColumn = function(column, callback) {
      return this.connection.knex().schema.hasColumn(this.table_name, column).exec(callback);
    };

    DatabaseTools.prototype.hasTable = function(callback) {
      return this.connection.knex().schema.hasTable(this.table_name).exec(callback);
    };

    DatabaseTools.prototype.dropTable = function(callback) {
      return this.connection.knex().schema.dropTable(this.table_name).exec(callback);
    };

    DatabaseTools.prototype.dropTableIfExists = function(callback) {
      return this.connection.knex().schema.dropTableIfExists(this.table_name).exec(callback);
    };

    DatabaseTools.prototype.renameTable = function(to, callback) {
      return this.connection.knex().schema.renameTable(this.table_name, to).exec(callback);
    };

    return DatabaseTools;

  })();

}).call(this);
