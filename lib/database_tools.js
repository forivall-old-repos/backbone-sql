// Generated by CoffeeScript 1.7.1

/*
  backbone-sql.js 0.5.7
  Copyright (c) 2013 Vidigami - https://github.com/vidigami/backbone-sql
  License: MIT (http://www.opensource.org/licenses/mit-license.php)
 */

(function() {
  var DatabaseTools, KNEX_COLUMN_OPERATORS, KNEX_COLUMN_OPTIONS, Knex, Queue, debounceCallback, inflection, _,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  _ = require('underscore');

  inflection = require('inflection');

  Knex = require('knex');

  Queue = require('backbone-orm/lib/queue');

  KNEX_COLUMN_OPERATORS = ['indexed', 'nullable', 'unique'];

  KNEX_COLUMN_OPTIONS = ['textType', 'length', 'precision', 'scale', 'value', 'values'];

  debounceCallback = function(callback) {
    var debounced_callback;
    return debounced_callback = function() {
      if (debounced_callback.was_called) {
        return;
      }
      debounced_callback.was_called = true;
      return callback.apply(null, Array.prototype.slice.call(arguments, 0));
    };
  };

  module.exports = DatabaseTools = (function() {
    function DatabaseTools(connection, table_name, schema, options) {
      var _ref;
      this.connection = connection;
      this.table_name = table_name;
      this.schema = schema;
      if (options == null) {
        options = {};
      }
      this.renameTable = __bind(this.renameTable, this);
      this.dropTableIfExists = __bind(this.dropTableIfExists, this);
      this.dropTable = __bind(this.dropTable, this);
      this.hasTable = __bind(this.hasTable, this);
      this.hasColumn = __bind(this.hasColumn, this);
      this.ensureColumn = __bind(this.ensureColumn, this);
      this.ensureField = __bind(this.ensureField, this);
      this.ensureRelation = __bind(this.ensureRelation, this);
      this.ensureSchema = __bind(this.ensureSchema, this);
      this.resetSchema = __bind(this.resetSchema, this);
      this.resetRelation = __bind(this.resetRelation, this);
      this.addRelation = __bind(this.addRelation, this);
      this.addColumn = __bind(this.addColumn, this);
      this.addField = __bind(this.addField, this);
      this.editTable = __bind(this.editTable, this);
      this.createTable = __bind(this.createTable, this);
      this.strict = (_ref = options.strict) != null ? _ref : true;
      this.join_table_operations = [];
    }

    DatabaseTools.prototype.createTable = function(callback) {
      if (!_.isFunction(callback)) {
        throw new Error("createTable requires a callback");
      }
      callback = debounceCallback(callback);
      this.connection.knex().schema.createTable(this.table_name, (function(_this) {
        return function(t) {
          return callback(null, t);
        };
      })(this)).exec(callback);
      return this;
    };

    DatabaseTools.prototype.editTable = function(callback) {
      if (!_.isFunction(callback)) {
        throw new Error("editTable requires a callback");
      }
      callback = debounceCallback(callback);
      this.connection.knex().schema.table(this.table_name, (function(_this) {
        return function(t) {
          return callback(null, t);
        };
      })(this)).exec(callback);
      return this;
    };

    DatabaseTools.prototype.addField = function(key, field, callback) {
      var type;
      type = "" + (field.type[0].toLowerCase()) + (field.type.slice(1));
      this.addColumn(key, type, field, callback);
      return this;
    };

    DatabaseTools.prototype.addColumn = function(key, type, options, callback) {
      if (options == null) {
        options = {};
      }
      this.editTable((function(_this) {
        return function(err, table) {
          var column, column_args, constructor_options;
          if (err) {
            return callback(err);
          }
          column_args = [key];
          constructor_options = _.pick(options, KNEX_COLUMN_OPTIONS);
          if (!_.isEmpty(constructor_options)) {
            if (type === 'float' || type === 'decimal') {
              column_args[1] = constructor_options['precision'];
              column_args[2] = constructor_options['scale'];
            } else {
              column_args[1] = _.values(constructor_options)[0];
            }
          }
          column = table[type].apply(table, column_args);
          if (options.primary) {
            column.primary();
          }
          if (options.nullable === false) {
            column.notNullable();
          }
          if (options.indexed) {
            column.index();
          }
          if (options.unique) {
            column.unique();
          }
          return callback();
        };
      })(this));
      return this;
    };

    DatabaseTools.prototype.addRelation = function(key, relation, callback) {
      if (relation.isVirtual()) {
        return callback();
      }
      if (relation.type === 'belongsTo') {
        this.addColumn(relation.foreign_key, 'integer', ['nullable', 'index'], callback);
      } else if (relation.type === 'hasMany' && relation.reverse_relation.type === 'hasMany') {
        this.join_table_operations.push(function(callback) {
          return relation.findOrGenerateJoinTable().db().ensureSchema(callback);
        });
      }
      return this;
    };

    DatabaseTools.prototype.resetRelation = function(key, relation, callback) {
      if (relation.isVirtual()) {
        return callback();
      }
      if (relation.type === 'belongsTo') {
        this.addColumn(relation.foreign_key, 'integer', ['nullable', 'index'], callback);
      } else if (relation.type === 'hasMany' && relation.reverse_relation.type === 'hasMany') {
        this.join_table_operations.push(function(callback) {
          return relation.findOrGenerateJoinTable().resetSchema(callback);
        });
      }
      return this;
    };

    DatabaseTools.prototype.resetSchema = function(options, callback) {
      var _ref;
      if (arguments.length === 1) {
        _ref = [options, {}], callback = _ref[0], options = _ref[1];
      }
      return this.connection.knex().schema.dropTableIfExists(this.table_name).exec((function(_this) {
        return function(err) {
          if (err) {
            return callback(err);
          }
          return _this.ensureSchema(options, callback);
        };
      })(this));
    };

    DatabaseTools.prototype.ensureSchema = function(options, callback) {
      var field, key, queue, relation, _fn, _fn1, _ref, _ref1, _ref2;
      if (arguments.length === 1) {
        _ref = [options, {}], callback = _ref[0], options = _ref[1];
      }
      if (this.ensuring) {
        return callback();
      }
      this.ensuring = true;
      queue = new Queue(1);
      queue.defer((function(_this) {
        return function(callback) {
          return _this.hasTable(function(err, table_exists) {
            if (err) {
              return callback(err);
            }
            if (options.verbose) {
              console.log("Ensuring table: " + _this.table_name + " (exists: " + (!!table_exists) + ") with fields: '" + (_.keys(_this.schema.fields).join(', ')) + "' and relations: '" + (_.keys(_this.schema.relations).join(', ')) + "'");
            }
            if (table_exists) {
              return callback();
            }
            return _this.createTable(callback);
          });
        };
      })(this));
      queue.defer((function(_this) {
        return function(callback) {
          return _this.ensureColumn('id', 'increments', {
            primary: true,
            indexed: true
          }, callback);
        };
      })(this));
      _ref1 = this.schema.fields;
      _fn = (function(_this) {
        return function(key, field) {
          return queue.defer(function(callback) {
            return _this.ensureField(key, field, callback);
          });
        };
      })(this);
      for (key in _ref1) {
        field = _ref1[key];
        _fn(key, field);
      }
      _ref2 = this.schema.relations;
      _fn1 = (function(_this) {
        return function(key, relation) {
          return queue.defer(function(callback) {
            return _this.ensureRelation(key, relation, callback);
          });
        };
      })(this);
      for (key in _ref2) {
        relation = _ref2[key];
        _fn1(key, relation);
      }
      return queue.await((function(_this) {
        return function(err) {
          var join_table_fn, _fn2, _i, _len, _ref3;
          _this.ensuring = false;
          if (err) {
            return callback(err);
          }
          if (!_this.join_table_operations.length) {
            return callback();
          }
          queue = new Queue(1);
          _ref3 = _this.join_table_operations.splice(0, _this.join_table_operations.length);
          _fn2 = function(join_table_fn) {
            return queue.defer(function(callback) {
              return join_table_fn(callback);
            });
          };
          for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
            join_table_fn = _ref3[_i];
            _fn2(join_table_fn);
          }
          return queue.await(callback);
        };
      })(this));
    };

    DatabaseTools.prototype.ensureRelation = function(key, relation, callback) {
      if (relation.type === 'belongsTo') {
        return this.hasColumn(relation.foreign_key, (function(_this) {
          return function(err, column_exists) {
            if (err) {
              return callback(err);
            }
            if (column_exists) {
              return callback();
            } else {
              return _this.addRelation(key, relation, callback);
            }
          };
        })(this));
      } else if (relation.type === 'hasMany' && relation.reverse_relation.type === 'hasMany') {
        return relation.findOrGenerateJoinTable().db().ensureSchema(callback);
      } else {
        return callback();
      }
    };

    DatabaseTools.prototype.ensureField = function(key, field, callback) {
      return this.hasColumn(key, (function(_this) {
        return function(err, column_exists) {
          if (err) {
            return callback(err);
          }
          if (column_exists) {
            return callback();
          } else {
            return _this.addField(key, field, callback);
          }
        };
      })(this));
    };

    DatabaseTools.prototype.ensureColumn = function(key, type, options, callback) {
      return this.hasColumn(key, (function(_this) {
        return function(err, column_exists) {
          if (err) {
            return callback(err);
          }
          if (column_exists) {
            return callback();
          } else {
            return _this.addColumn(key, type, options, callback);
          }
        };
      })(this));
    };

    DatabaseTools.prototype.hasColumn = function(column, callback) {
      return this.connection.knex().schema.hasColumn(this.table_name, column).exec(callback);
    };

    DatabaseTools.prototype.hasTable = function(callback) {
      return this.connection.knex().schema.hasTable(this.table_name).exec(callback);
    };

    DatabaseTools.prototype.dropTable = function(callback) {
      return this.connection.knex().schema.dropTable(this.table_name).exec(callback);
    };

    DatabaseTools.prototype.dropTableIfExists = function(callback) {
      return this.connection.knex().schema.dropTableIfExists(this.table_name).exec(callback);
    };

    DatabaseTools.prototype.renameTable = function(to, callback) {
      return this.connection.knex().schema.renameTable(this.table_name, to).exec(callback);
    };

    return DatabaseTools;

  })();

}).call(this);
